/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v12.0.12.0 (NJsonSchema v9.13.15.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

export class AccountRoleClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getRole(): Promise<AccountRole[] | null> {
        let url_ = this.baseUrl + "/api/AccountRole";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRole(_response);
        });
    }

    protected processGetRole(response: Response): Promise<AccountRole[] | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AccountRole.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AccountRole[] | null>(<any>null);
    }
}

export class AssociateClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    get(): Promise<Associate[] | null> {
        let url_ = this.baseUrl + "/api/Associate";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<Associate[] | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Associate.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Associate[] | null>(<any>null);
    }

    query(projectId: string, projectGroupId: string | null): Promise<AssociateProjectGroup[] | null> {
        let url_ = this.baseUrl + "/api/Associate/Query?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined and cannot be null.");
        else
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&"; 
        if (projectGroupId === undefined)
            throw new Error("The parameter 'projectGroupId' must be defined.");
        else
            url_ += "projectGroupId=" + encodeURIComponent("" + projectGroupId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processQuery(_response);
        });
    }

    protected processQuery(response: Response): Promise<AssociateProjectGroup[] | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AssociateProjectGroup.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AssociateProjectGroup[] | null>(<any>null);
    }
}

export class AssociateDetailsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    get(pageRequest: PageRequest | null): Promise<ResponseOfIListOfAssociateDetails | null> {
        let url_ = this.baseUrl + "/api/Associate/Details";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(pageRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<ResponseOfIListOfAssociateDetails | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResponseOfIListOfAssociateDetails.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseOfIListOfAssociateDetails | null>(<any>null);
    }

    post(request: AssociateDetails | null): Promise<AssociateDetails | null> {
        let url_ = this.baseUrl + "/api/AssociateDetails";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<AssociateDetails | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AssociateDetails.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AssociateDetails | null>(<any>null);
    }

    put(request: UpdateAssociateDetails | null): Promise<UpdateAssociateDetails | null> {
        let url_ = this.baseUrl + "/api/AssociateDetails";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPut(_response);
        });
    }

    protected processPut(response: Response): Promise<UpdateAssociateDetails | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UpdateAssociateDetails.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UpdateAssociateDetails | null>(<any>null);
    }

    delate(id: string): Promise<DeleteAssociateDetails | null> {
        let url_ = this.baseUrl + "/api/AssociateDetails?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelate(_response);
        });
    }

    protected processDelate(response: Response): Promise<DeleteAssociateDetails | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DeleteAssociateDetails.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DeleteAssociateDetails | null>(<any>null);
    }
}

export class AssociatePlanClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    query(): Promise<AssociatePlan[] | null> {
        let url_ = this.baseUrl + "/api/AssociatePlan/query";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processQuery(_response);
        });
    }

    protected processQuery(response: Response): Promise<AssociatePlan[] | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AssociatePlan.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AssociatePlan[] | null>(<any>null);
    }

    getAssociatePlanStatus(projectGroupPlanId: string): Promise<AssociatePlan[] | null> {
        let url_ = this.baseUrl + "/api/AssociatePlan?";
        if (projectGroupPlanId === undefined || projectGroupPlanId === null)
            throw new Error("The parameter 'projectGroupPlanId' must be defined and cannot be null.");
        else
            url_ += "projectGroupPlanId=" + encodeURIComponent("" + projectGroupPlanId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAssociatePlanStatus(_response);
        });
    }

    protected processGetAssociatePlanStatus(response: Response): Promise<AssociatePlan[] | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AssociatePlan.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AssociatePlan[] | null>(<any>null);
    }

    upload(id: string): Promise<string | null> {
        let url_ = this.baseUrl + "/api/AssociatePlan/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpload(_response);
        });
    }

    protected processUpload(response: Response): Promise<string | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string | null>(<any>null);
    }

    put(id: string, request: UpdateAssociatePlan | null): Promise<AssociatePlan | null> {
        let url_ = this.baseUrl + "/api/AssociatePlan/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPut(_response);
        });
    }

    protected processPut(response: Response): Promise<AssociatePlan | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AssociatePlan.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AssociatePlan | null>(<any>null);
    }
}

export class DashboardClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    get(): Promise<Dashboard[] | null> {
        let url_ = this.baseUrl + "/api/Dashboard";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<Dashboard[] | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Dashboard.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Dashboard[] | null>(<any>null);
    }
}

export class KnowledgeTransferClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    get(): Promise<KnowledgeTransfer[] | null> {
        let url_ = this.baseUrl + "/api/KnowledgeTransfer";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<KnowledgeTransfer[] | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(KnowledgeTransfer.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<KnowledgeTransfer[] | null>(<any>null);
    }
}

export class ModeClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    get(): Promise<Mode[] | null> {
        let url_ = this.baseUrl + "/api/Mode";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<Mode[] | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Mode.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Mode[] | null>(<any>null);
    }
}

export class ProjectClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    get(): Promise<Project[] | null> {
        let url_ = this.baseUrl + "/api/Project";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<Project[] | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Project.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Project[] | null>(<any>null);
    }
}

export class ProjectGroupClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    query(projectId: string): Promise<ProjectGroup[] | null> {
        let url_ = this.baseUrl + "/api/ProjectGroup?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined and cannot be null.");
        else
            url_ += "ProjectId=" + encodeURIComponent("" + projectId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processQuery(_response);
        });
    }

    protected processQuery(response: Response): Promise<ProjectGroup[] | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectGroup.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProjectGroup[] | null>(<any>null);
    }

    post(request: ProcessCreateProjectGroup | null): Promise<ProjectGroup | null> {
        let url_ = this.baseUrl + "/api/ProjectGroup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<ProjectGroup | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ProjectGroup.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProjectGroup | null>(<any>null);
    }

    put(id: string, request: ProcessUpdateProjectGroup | null): Promise<ProjectGroup | null> {
        let url_ = this.baseUrl + "/api/ProjectGroup/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPut(_response);
        });
    }

    protected processPut(response: Response): Promise<ProjectGroup | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ProjectGroup.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProjectGroup | null>(<any>null);
    }

    delete(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/ProjectGroup/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class ProjectGroupPlanClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    query(projectGroupId: string): Promise<ProjectGroupPlanWithStatus[] | null> {
        let url_ = this.baseUrl + "/api/ProjectGroupPlan?";
        if (projectGroupId === undefined || projectGroupId === null)
            throw new Error("The parameter 'projectGroupId' must be defined and cannot be null.");
        else
            url_ += "ProjectGroupId=" + encodeURIComponent("" + projectGroupId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processQuery(_response);
        });
    }

    protected processQuery(response: Response): Promise<ProjectGroupPlanWithStatus[] | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectGroupPlanWithStatus.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProjectGroupPlanWithStatus[] | null>(<any>null);
    }

    post(request: CreateProjectGroupPlan | null): Promise<ProjectGroupPlan | null> {
        let url_ = this.baseUrl + "/api/ProjectGroupPlan";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<ProjectGroupPlan | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ProjectGroupPlan.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProjectGroupPlan | null>(<any>null);
    }

    put(id: string, request: UpdateProjectGroupPlan | null): Promise<ProjectGroupPlan | null> {
        let url_ = this.baseUrl + "/api/ProjectGroupPlan/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPut(_response);
        });
    }

    protected processPut(response: Response): Promise<ProjectGroupPlan | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ProjectGroupPlan.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProjectGroupPlan | null>(<any>null);
    }

    delete(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/ProjectGroupPlan/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class ProjectTeamClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getTeamList(projectId: string): Promise<Team[] | null> {
        let url_ = this.baseUrl + "/api/ProjectTeam?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined and cannot be null.");
        else
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTeamList(_response);
        });
    }

    protected processGetTeamList(response: Response): Promise<Team[] | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Team.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Team[] | null>(<any>null);
    }
}

export class RoleClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    get(): Promise<Role[] | null> {
        let url_ = this.baseUrl + "/api/Role";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<Role[] | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Role.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Role[] | null>(<any>null);
    }
}

export class UserRoleClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    get(): Promise<UserRole[] | null> {
        let url_ = this.baseUrl + "/api/UserRole";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<UserRole[] | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserRole.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserRole[] | null>(<any>null);
    }
}

export class AccountClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getUserInfo(): Promise<UserInfoViewModel | null> {
        let url_ = this.baseUrl + "/api/Account/UserInfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUserInfo(_response);
        });
    }

    protected processGetUserInfo(response: Response): Promise<UserInfoViewModel | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserInfoViewModel.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserInfoViewModel | null>(<any>null);
    }

    logout(): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Account/Logout";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogout(_response);
        });
    }

    protected processLogout(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(<any>null);
    }

    getManageInfo(returnUrl: string | null, generateState: boolean | undefined): Promise<ManageInfoViewModel | null> {
        let url_ = this.baseUrl + "/api/Account/ManageInfo?";
        if (returnUrl === undefined)
            throw new Error("The parameter 'returnUrl' must be defined.");
        else
            url_ += "returnUrl=" + encodeURIComponent("" + returnUrl) + "&"; 
        if (generateState === null)
            throw new Error("The parameter 'generateState' cannot be null.");
        else if (generateState !== undefined)
            url_ += "generateState=" + encodeURIComponent("" + generateState) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetManageInfo(_response);
        });
    }

    protected processGetManageInfo(response: Response): Promise<ManageInfoViewModel | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ManageInfoViewModel.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ManageInfoViewModel | null>(<any>null);
    }

    changePassword(model: ChangePasswordBindingModel | null): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Account/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processChangePassword(_response);
        });
    }

    protected processChangePassword(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(<any>null);
    }

    setPassword(model: SetPasswordBindingModel | null): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Account/SetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetPassword(_response);
        });
    }

    protected processSetPassword(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(<any>null);
    }

    addExternalLogin(model: AddExternalLoginBindingModel | null): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Account/AddExternalLogin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddExternalLogin(_response);
        });
    }

    protected processAddExternalLogin(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(<any>null);
    }

    removeLogin(model: RemoveLoginBindingModel | null): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Account/RemoveLogin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemoveLogin(_response);
        });
    }

    protected processRemoveLogin(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(<any>null);
    }

    getExternalLogin(provider: string | null, error: string | null | undefined): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Account/ExternalLogin?";
        if (provider === undefined)
            throw new Error("The parameter 'provider' must be defined.");
        else
            url_ += "provider=" + encodeURIComponent("" + provider) + "&"; 
        if (error !== undefined)
            url_ += "error=" + encodeURIComponent("" + error) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetExternalLogin(_response);
        });
    }

    protected processGetExternalLogin(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(<any>null);
    }

    getExternalLogins(returnUrl: string | null, generateState: boolean | undefined): Promise<ExternalLoginViewModel[] | null> {
        let url_ = this.baseUrl + "/api/Account/ExternalLogins?";
        if (returnUrl === undefined)
            throw new Error("The parameter 'returnUrl' must be defined.");
        else
            url_ += "returnUrl=" + encodeURIComponent("" + returnUrl) + "&"; 
        if (generateState === null)
            throw new Error("The parameter 'generateState' cannot be null.");
        else if (generateState !== undefined)
            url_ += "generateState=" + encodeURIComponent("" + generateState) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetExternalLogins(_response);
        });
    }

    protected processGetExternalLogins(response: Response): Promise<ExternalLoginViewModel[] | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ExternalLoginViewModel.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ExternalLoginViewModel[] | null>(<any>null);
    }

    register(model: RegisterBindingModel | null): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Account/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRegister(_response);
        });
    }

    protected processRegister(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(<any>null);
    }

    registerExternal(model: RegisterExternalBindingModel | null): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Account/RegisterExternal";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRegisterExternal(_response);
        });
    }

    protected processRegisterExternal(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(<any>null);
    }
}

export class MigrationClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    get(): Promise<void> {
        let url_ = this.baseUrl + "/api/Migration";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class UpdateMigrationClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    get(id: boolean): Promise<void> {
        let url_ = this.baseUrl + "/api/UpdateMigration/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class AccountRole implements IAccountRole {
    id!: string;
    code?: string | undefined;
    name?: string | undefined;

    constructor(data?: IAccountRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.code = data["Code"];
            this.name = data["Name"];
        }
    }

    static fromJS(data: any): AccountRole {
        data = typeof data === 'object' ? data : {};
        let result = new AccountRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Code"] = this.code;
        data["Name"] = this.name;
        return data; 
    }
}

export interface IAccountRole {
    id: string;
    code?: string | undefined;
    name?: string | undefined;
}

export class Associate implements IAssociate {
    id!: string;
    name?: string | undefined;
    code?: string | undefined;
    roleId!: string;
    projectId!: string;

    constructor(data?: IAssociate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.name = data["Name"];
            this.code = data["Code"];
            this.roleId = data["RoleId"];
            this.projectId = data["ProjectId"];
        }
    }

    static fromJS(data: any): Associate {
        data = typeof data === 'object' ? data : {};
        let result = new Associate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["Code"] = this.code;
        data["RoleId"] = this.roleId;
        data["ProjectId"] = this.projectId;
        return data; 
    }
}

export interface IAssociate {
    id: string;
    name?: string | undefined;
    code?: string | undefined;
    roleId: string;
    projectId: string;
}

export class AssociateProjectGroup implements IAssociateProjectGroup {
    id!: string;
    associateGroupId?: string | undefined;
    name?: string | undefined;
    code?: string | undefined;
    roleId!: string;
    isGroup!: boolean;

    constructor(data?: IAssociateProjectGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.associateGroupId = data["AssociateGroupId"];
            this.name = data["Name"];
            this.code = data["Code"];
            this.roleId = data["RoleId"];
            this.isGroup = data["IsGroup"];
        }
    }

    static fromJS(data: any): AssociateProjectGroup {
        data = typeof data === 'object' ? data : {};
        let result = new AssociateProjectGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["AssociateGroupId"] = this.associateGroupId;
        data["Name"] = this.name;
        data["Code"] = this.code;
        data["RoleId"] = this.roleId;
        data["IsGroup"] = this.isGroup;
        return data; 
    }
}

export interface IAssociateProjectGroup {
    id: string;
    associateGroupId?: string | undefined;
    name?: string | undefined;
    code?: string | undefined;
    roleId: string;
    isGroup: boolean;
}

export class ResponseOfIListOfAssociateDetails implements IResponseOfIListOfAssociateDetails {
    totalNumberOfRecords!: number;
    result?: AssociateDetails[] | undefined;

    constructor(data?: IResponseOfIListOfAssociateDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalNumberOfRecords = data["TotalNumberOfRecords"];
            if (data["Result"] && data["Result"].constructor === Array) {
                this.result = [] as any;
                for (let item of data["Result"])
                    this.result!.push(AssociateDetails.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResponseOfIListOfAssociateDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseOfIListOfAssociateDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TotalNumberOfRecords"] = this.totalNumberOfRecords;
        if (this.result && this.result.constructor === Array) {
            data["Result"] = [];
            for (let item of this.result)
                data["Result"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IResponseOfIListOfAssociateDetails {
    totalNumberOfRecords: number;
    result?: AssociateDetails[] | undefined;
}

export class AssociateDetails implements IAssociateDetails {
    associateId!: string;
    designationId?: string | undefined;
    cognizantId?: string | undefined;
    associateName?: string | undefined;
    fNZUserName?: string | undefined;
    fNZStaffId?: string | undefined;
    fNZRoleId?: string | undefined;
    fNZEmail?: string | undefined;
    assetNo?: string | undefined;
    virtualMachineNo?: string | undefined;
    portfolio?: string | undefined;
    fNZDateofJoining?: Date | undefined;
    fNZDateofLeaving?: Date | undefined;
    fNZExperience?: number | undefined;
    billable?: string | undefined;
    location?: string | undefined;
    contactNo?: string | undefined;
    projectId!: string;
    teamId?: string | undefined;
    cognizantRoleId!: string;
    cognizantEmailId?: string | undefined;
    projectName?: string | undefined;
    city?: string | undefined;
    skillSet?: string | undefined;
    experienceOfAssociate?: number | undefined;
    fse?: boolean | undefined;

    constructor(data?: IAssociateDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.associateId = data["AssociateId"];
            this.designationId = data["DesignationId"];
            this.cognizantId = data["CognizantId"];
            this.associateName = data["AssociateName"];
            this.fNZUserName = data["FNZUserName"];
            this.fNZStaffId = data["FNZStaffId"];
            this.fNZRoleId = data["FNZRoleId"];
            this.fNZEmail = data["FNZEmail"];
            this.assetNo = data["AssetNo"];
            this.virtualMachineNo = data["VirtualMachineNo"];
            this.portfolio = data["Portfolio"];
            this.fNZDateofJoining = data["FNZDateofJoining"] ? new Date(data["FNZDateofJoining"].toString()) : <any>undefined;
            this.fNZDateofLeaving = data["FNZDateofLeaving"] ? new Date(data["FNZDateofLeaving"].toString()) : <any>undefined;
            this.fNZExperience = data["FNZExperience"];
            this.billable = data["Billable"];
            this.location = data["Location"];
            this.contactNo = data["ContactNo"];
            this.projectId = data["ProjectId"];
            this.teamId = data["TeamId"];
            this.cognizantRoleId = data["CognizantRoleId"];
            this.cognizantEmailId = data["CognizantEmailId"];
            this.projectName = data["ProjectName"];
            this.city = data["City"];
            this.skillSet = data["SkillSet"];
            this.experienceOfAssociate = data["ExperienceOfAssociate"];
            this.fse = data["Fse"];
        }
    }

    static fromJS(data: any): AssociateDetails {
        data = typeof data === 'object' ? data : {};
        let result = new AssociateDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["AssociateId"] = this.associateId;
        data["DesignationId"] = this.designationId;
        data["CognizantId"] = this.cognizantId;
        data["AssociateName"] = this.associateName;
        data["FNZUserName"] = this.fNZUserName;
        data["FNZStaffId"] = this.fNZStaffId;
        data["FNZRoleId"] = this.fNZRoleId;
        data["FNZEmail"] = this.fNZEmail;
        data["AssetNo"] = this.assetNo;
        data["VirtualMachineNo"] = this.virtualMachineNo;
        data["Portfolio"] = this.portfolio;
        data["FNZDateofJoining"] = this.fNZDateofJoining ? this.fNZDateofJoining.toISOString() : <any>undefined;
        data["FNZDateofLeaving"] = this.fNZDateofLeaving ? this.fNZDateofLeaving.toISOString() : <any>undefined;
        data["FNZExperience"] = this.fNZExperience;
        data["Billable"] = this.billable;
        data["Location"] = this.location;
        data["ContactNo"] = this.contactNo;
        data["ProjectId"] = this.projectId;
        data["TeamId"] = this.teamId;
        data["CognizantRoleId"] = this.cognizantRoleId;
        data["CognizantEmailId"] = this.cognizantEmailId;
        data["ProjectName"] = this.projectName;
        data["City"] = this.city;
        data["SkillSet"] = this.skillSet;
        data["ExperienceOfAssociate"] = this.experienceOfAssociate;
        data["Fse"] = this.fse;
        return data; 
    }
}

export interface IAssociateDetails {
    associateId: string;
    designationId?: string | undefined;
    cognizantId?: string | undefined;
    associateName?: string | undefined;
    fNZUserName?: string | undefined;
    fNZStaffId?: string | undefined;
    fNZRoleId?: string | undefined;
    fNZEmail?: string | undefined;
    assetNo?: string | undefined;
    virtualMachineNo?: string | undefined;
    portfolio?: string | undefined;
    fNZDateofJoining?: Date | undefined;
    fNZDateofLeaving?: Date | undefined;
    fNZExperience?: number | undefined;
    billable?: string | undefined;
    location?: string | undefined;
    contactNo?: string | undefined;
    projectId: string;
    teamId?: string | undefined;
    cognizantRoleId: string;
    cognizantEmailId?: string | undefined;
    projectName?: string | undefined;
    city?: string | undefined;
    skillSet?: string | undefined;
    experienceOfAssociate?: number | undefined;
    fse?: boolean | undefined;
}

export class PageRequest implements IPageRequest {
    pageNumber!: number;
    perPageCount!: number;
    sortColumns?: { [key: string] : boolean; } | undefined;
    searchParams?: { [key: string] : string; } | undefined;

    constructor(data?: IPageRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.pageNumber = data["PageNumber"];
            this.perPageCount = data["PerPageCount"];
            if (data["SortColumns"]) {
                this.sortColumns = {} as any;
                for (let key in data["SortColumns"]) {
                    if (data["SortColumns"].hasOwnProperty(key))
                        this.sortColumns![key] = data["SortColumns"][key];
                }
            }
            if (data["SearchParams"]) {
                this.searchParams = {} as any;
                for (let key in data["SearchParams"]) {
                    if (data["SearchParams"].hasOwnProperty(key))
                        this.searchParams![key] = data["SearchParams"][key];
                }
            }
        }
    }

    static fromJS(data: any): PageRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PageRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["PageNumber"] = this.pageNumber;
        data["PerPageCount"] = this.perPageCount;
        if (this.sortColumns) {
            data["SortColumns"] = {};
            for (let key in this.sortColumns) {
                if (this.sortColumns.hasOwnProperty(key))
                    data["SortColumns"][key] = this.sortColumns[key];
            }
        }
        if (this.searchParams) {
            data["SearchParams"] = {};
            for (let key in this.searchParams) {
                if (this.searchParams.hasOwnProperty(key))
                    data["SearchParams"][key] = this.searchParams[key];
            }
        }
        return data; 
    }
}

export interface IPageRequest {
    pageNumber: number;
    perPageCount: number;
    sortColumns?: { [key: string] : boolean; } | undefined;
    searchParams?: { [key: string] : string; } | undefined;
}

export class UpdateAssociateDetails implements IUpdateAssociateDetails {
    associateId!: string;
    designationId?: string | undefined;
    cognizantId?: string | undefined;
    associateName?: string | undefined;
    fNZUserName?: string | undefined;
    fNZStaffId?: string | undefined;
    fNZRoleId?: string | undefined;
    fNZEmail?: string | undefined;
    assetNo?: string | undefined;
    virtualMachineNo?: string | undefined;
    portfolio?: string | undefined;
    fNZDateofJoining?: Date | undefined;
    fNZDateofLeaving?: Date | undefined;
    fNZExperience?: number | undefined;
    billable?: string | undefined;
    location?: string | undefined;
    contactNo?: string | undefined;
    projectId!: string;
    teamId?: string | undefined;
    cognizantRoleId!: string;
    cognizantEmailId?: string | undefined;
    projectName?: string | undefined;
    city?: string | undefined;
    skillSet?: string | undefined;
    experienceOfAssociate?: number | undefined;
    fse?: boolean | undefined;

    constructor(data?: IUpdateAssociateDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.associateId = data["AssociateId"];
            this.designationId = data["DesignationId"];
            this.cognizantId = data["CognizantId"];
            this.associateName = data["AssociateName"];
            this.fNZUserName = data["FNZUserName"];
            this.fNZStaffId = data["FNZStaffId"];
            this.fNZRoleId = data["FNZRoleId"];
            this.fNZEmail = data["FNZEmail"];
            this.assetNo = data["AssetNo"];
            this.virtualMachineNo = data["VirtualMachineNo"];
            this.portfolio = data["Portfolio"];
            this.fNZDateofJoining = data["FNZDateofJoining"] ? new Date(data["FNZDateofJoining"].toString()) : <any>undefined;
            this.fNZDateofLeaving = data["FNZDateofLeaving"] ? new Date(data["FNZDateofLeaving"].toString()) : <any>undefined;
            this.fNZExperience = data["FNZExperience"];
            this.billable = data["Billable"];
            this.location = data["Location"];
            this.contactNo = data["ContactNo"];
            this.projectId = data["ProjectId"];
            this.teamId = data["TeamId"];
            this.cognizantRoleId = data["CognizantRoleId"];
            this.cognizantEmailId = data["CognizantEmailId"];
            this.projectName = data["ProjectName"];
            this.city = data["City"];
            this.skillSet = data["SkillSet"];
            this.experienceOfAssociate = data["ExperienceOfAssociate"];
            this.fse = data["Fse"];
        }
    }

    static fromJS(data: any): UpdateAssociateDetails {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAssociateDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["AssociateId"] = this.associateId;
        data["DesignationId"] = this.designationId;
        data["CognizantId"] = this.cognizantId;
        data["AssociateName"] = this.associateName;
        data["FNZUserName"] = this.fNZUserName;
        data["FNZStaffId"] = this.fNZStaffId;
        data["FNZRoleId"] = this.fNZRoleId;
        data["FNZEmail"] = this.fNZEmail;
        data["AssetNo"] = this.assetNo;
        data["VirtualMachineNo"] = this.virtualMachineNo;
        data["Portfolio"] = this.portfolio;
        data["FNZDateofJoining"] = this.fNZDateofJoining ? this.fNZDateofJoining.toISOString() : <any>undefined;
        data["FNZDateofLeaving"] = this.fNZDateofLeaving ? this.fNZDateofLeaving.toISOString() : <any>undefined;
        data["FNZExperience"] = this.fNZExperience;
        data["Billable"] = this.billable;
        data["Location"] = this.location;
        data["ContactNo"] = this.contactNo;
        data["ProjectId"] = this.projectId;
        data["TeamId"] = this.teamId;
        data["CognizantRoleId"] = this.cognizantRoleId;
        data["CognizantEmailId"] = this.cognizantEmailId;
        data["ProjectName"] = this.projectName;
        data["City"] = this.city;
        data["SkillSet"] = this.skillSet;
        data["ExperienceOfAssociate"] = this.experienceOfAssociate;
        data["Fse"] = this.fse;
        return data; 
    }
}

export interface IUpdateAssociateDetails {
    associateId: string;
    designationId?: string | undefined;
    cognizantId?: string | undefined;
    associateName?: string | undefined;
    fNZUserName?: string | undefined;
    fNZStaffId?: string | undefined;
    fNZRoleId?: string | undefined;
    fNZEmail?: string | undefined;
    assetNo?: string | undefined;
    virtualMachineNo?: string | undefined;
    portfolio?: string | undefined;
    fNZDateofJoining?: Date | undefined;
    fNZDateofLeaving?: Date | undefined;
    fNZExperience?: number | undefined;
    billable?: string | undefined;
    location?: string | undefined;
    contactNo?: string | undefined;
    projectId: string;
    teamId?: string | undefined;
    cognizantRoleId: string;
    cognizantEmailId?: string | undefined;
    projectName?: string | undefined;
    city?: string | undefined;
    skillSet?: string | undefined;
    experienceOfAssociate?: number | undefined;
    fse?: boolean | undefined;
}

export class DeleteAssociateDetails implements IDeleteAssociateDetails {
    associateId!: string;

    constructor(data?: IDeleteAssociateDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.associateId = data["AssociateId"];
        }
    }

    static fromJS(data: any): DeleteAssociateDetails {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteAssociateDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["AssociateId"] = this.associateId;
        return data; 
    }
}

export interface IDeleteAssociateDetails {
    associateId: string;
}

export class AssociatePlan implements IAssociatePlan {
    id!: string;
    associateId!: string;
    associateCode?: string | undefined;
    associateName?: string | undefined;
    ownerName?: string | undefined;
    modeName?: string | undefined;
    reference?: string | undefined;
    knowledgeTransferTitle?: string | undefined;
    duration!: number;
    week!: number;
    day!: number;
    scheduledDate!: Date;
    completionDate?: Date | undefined;
    proof?: string | undefined;
    proofType!: number;

    constructor(data?: IAssociatePlan) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.associateId = data["AssociateId"];
            this.associateCode = data["AssociateCode"];
            this.associateName = data["AssociateName"];
            this.ownerName = data["OwnerName"];
            this.modeName = data["ModeName"];
            this.reference = data["Reference"];
            this.knowledgeTransferTitle = data["KnowledgeTransferTitle"];
            this.duration = data["Duration"];
            this.week = data["Week"];
            this.day = data["Day"];
            this.scheduledDate = data["ScheduledDate"] ? new Date(data["ScheduledDate"].toString()) : <any>undefined;
            this.completionDate = data["CompletionDate"] ? new Date(data["CompletionDate"].toString()) : <any>undefined;
            this.proof = data["Proof"];
            this.proofType = data["ProofType"];
        }
    }

    static fromJS(data: any): AssociatePlan {
        data = typeof data === 'object' ? data : {};
        let result = new AssociatePlan();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["AssociateId"] = this.associateId;
        data["AssociateCode"] = this.associateCode;
        data["AssociateName"] = this.associateName;
        data["OwnerName"] = this.ownerName;
        data["ModeName"] = this.modeName;
        data["Reference"] = this.reference;
        data["KnowledgeTransferTitle"] = this.knowledgeTransferTitle;
        data["Duration"] = this.duration;
        data["Week"] = this.week;
        data["Day"] = this.day;
        data["ScheduledDate"] = this.scheduledDate ? this.scheduledDate.toISOString() : <any>undefined;
        data["CompletionDate"] = this.completionDate ? this.completionDate.toISOString() : <any>undefined;
        data["Proof"] = this.proof;
        data["ProofType"] = this.proofType;
        return data; 
    }
}

export interface IAssociatePlan {
    id: string;
    associateId: string;
    associateCode?: string | undefined;
    associateName?: string | undefined;
    ownerName?: string | undefined;
    modeName?: string | undefined;
    reference?: string | undefined;
    knowledgeTransferTitle?: string | undefined;
    duration: number;
    week: number;
    day: number;
    scheduledDate: Date;
    completionDate?: Date | undefined;
    proof?: string | undefined;
    proofType: number;
}

export class UpdateAssociatePlan implements IUpdateAssociatePlan {
    id!: string;
    status!: boolean;
    completionDate!: Date;

    constructor(data?: IUpdateAssociatePlan) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.status = data["Status"];
            this.completionDate = data["CompletionDate"] ? new Date(data["CompletionDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateAssociatePlan {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAssociatePlan();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Status"] = this.status;
        data["CompletionDate"] = this.completionDate ? this.completionDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IUpdateAssociatePlan {
    id: string;
    status: boolean;
    completionDate: Date;
}

export class Dashboard implements IDashboard {
    projectId!: string;
    teamId?: string | undefined;
    roleId?: string | undefined;
    projectName?: string | undefined;
    teamName?: string | undefined;
    roleName?: string | undefined;
    count!: number;
    completedCount!: number;

    constructor(data?: IDashboard) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.projectId = data["ProjectId"];
            this.teamId = data["TeamId"];
            this.roleId = data["RoleId"];
            this.projectName = data["ProjectName"];
            this.teamName = data["TeamName"];
            this.roleName = data["RoleName"];
            this.count = data["Count"];
            this.completedCount = data["CompletedCount"];
        }
    }

    static fromJS(data: any): Dashboard {
        data = typeof data === 'object' ? data : {};
        let result = new Dashboard();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ProjectId"] = this.projectId;
        data["TeamId"] = this.teamId;
        data["RoleId"] = this.roleId;
        data["ProjectName"] = this.projectName;
        data["TeamName"] = this.teamName;
        data["RoleName"] = this.roleName;
        data["Count"] = this.count;
        data["CompletedCount"] = this.completedCount;
        return data; 
    }
}

export interface IDashboard {
    projectId: string;
    teamId?: string | undefined;
    roleId?: string | undefined;
    projectName?: string | undefined;
    teamName?: string | undefined;
    roleName?: string | undefined;
    count: number;
    completedCount: number;
}

export class KnowledgeTransfer implements IKnowledgeTransfer {
    id!: string;
    name?: string | undefined;
    description?: string | undefined;
    modeId!: string;
    ownerId?: string | undefined;
    reference?: string | undefined;
    duration!: number;

    constructor(data?: IKnowledgeTransfer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.name = data["Name"];
            this.description = data["Description"];
            this.modeId = data["ModeId"];
            this.ownerId = data["OwnerId"];
            this.reference = data["Reference"];
            this.duration = data["Duration"];
        }
    }

    static fromJS(data: any): KnowledgeTransfer {
        data = typeof data === 'object' ? data : {};
        let result = new KnowledgeTransfer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["Description"] = this.description;
        data["ModeId"] = this.modeId;
        data["OwnerId"] = this.ownerId;
        data["Reference"] = this.reference;
        data["Duration"] = this.duration;
        return data; 
    }
}

export interface IKnowledgeTransfer {
    id: string;
    name?: string | undefined;
    description?: string | undefined;
    modeId: string;
    ownerId?: string | undefined;
    reference?: string | undefined;
    duration: number;
}

export class Mode implements IMode {
    id!: string;
    code?: string | undefined;
    name?: string | undefined;

    constructor(data?: IMode) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.code = data["Code"];
            this.name = data["Name"];
        }
    }

    static fromJS(data: any): Mode {
        data = typeof data === 'object' ? data : {};
        let result = new Mode();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Code"] = this.code;
        data["Name"] = this.name;
        return data; 
    }
}

export interface IMode {
    id: string;
    code?: string | undefined;
    name?: string | undefined;
}

export class Project implements IProject {
    id!: string;
    code?: string | undefined;
    name?: string | undefined;

    constructor(data?: IProject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.code = data["Code"];
            this.name = data["Name"];
        }
    }

    static fromJS(data: any): Project {
        data = typeof data === 'object' ? data : {};
        let result = new Project();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Code"] = this.code;
        data["Name"] = this.name;
        return data; 
    }
}

export interface IProject {
    id: string;
    code?: string | undefined;
    name?: string | undefined;
}

export class ProjectGroup implements IProjectGroup {
    id!: string;
    projectId!: string;
    name?: string | undefined;
    startDate!: Date;
    description?: string | undefined;
    active!: boolean;

    constructor(data?: IProjectGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.projectId = data["ProjectId"];
            this.name = data["Name"];
            this.startDate = data["StartDate"] ? new Date(data["StartDate"].toString()) : <any>undefined;
            this.description = data["Description"];
            this.active = data["Active"];
        }
    }

    static fromJS(data: any): ProjectGroup {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["ProjectId"] = this.projectId;
        data["Name"] = this.name;
        data["StartDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["Description"] = this.description;
        data["Active"] = this.active;
        return data; 
    }
}

export interface IProjectGroup {
    id: string;
    projectId: string;
    name?: string | undefined;
    startDate: Date;
    description?: string | undefined;
    active: boolean;
}

export class ProcessCreateProjectGroup implements IProcessCreateProjectGroup {
    projectId!: string;
    name?: string | undefined;
    startDate!: Date;
    addAssociates?: Associate[] | undefined;

    constructor(data?: IProcessCreateProjectGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.projectId = data["ProjectId"];
            this.name = data["Name"];
            this.startDate = data["StartDate"] ? new Date(data["StartDate"].toString()) : <any>undefined;
            if (data["AddAssociates"] && data["AddAssociates"].constructor === Array) {
                this.addAssociates = [] as any;
                for (let item of data["AddAssociates"])
                    this.addAssociates!.push(Associate.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProcessCreateProjectGroup {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessCreateProjectGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ProjectId"] = this.projectId;
        data["Name"] = this.name;
        data["StartDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        if (this.addAssociates && this.addAssociates.constructor === Array) {
            data["AddAssociates"] = [];
            for (let item of this.addAssociates)
                data["AddAssociates"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IProcessCreateProjectGroup {
    projectId: string;
    name?: string | undefined;
    startDate: Date;
    addAssociates?: Associate[] | undefined;
}

export class ProcessUpdateProjectGroup implements IProcessUpdateProjectGroup {
    projectGroupId!: string;
    name?: string | undefined;
    startDate!: Date;
    addAssociates?: Associate[] | undefined;
    deleteAssociates?: Associate[] | undefined;

    constructor(data?: IProcessUpdateProjectGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.projectGroupId = data["ProjectGroupId"];
            this.name = data["Name"];
            this.startDate = data["StartDate"] ? new Date(data["StartDate"].toString()) : <any>undefined;
            if (data["AddAssociates"] && data["AddAssociates"].constructor === Array) {
                this.addAssociates = [] as any;
                for (let item of data["AddAssociates"])
                    this.addAssociates!.push(Associate.fromJS(item));
            }
            if (data["DeleteAssociates"] && data["DeleteAssociates"].constructor === Array) {
                this.deleteAssociates = [] as any;
                for (let item of data["DeleteAssociates"])
                    this.deleteAssociates!.push(Associate.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProcessUpdateProjectGroup {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessUpdateProjectGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ProjectGroupId"] = this.projectGroupId;
        data["Name"] = this.name;
        data["StartDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        if (this.addAssociates && this.addAssociates.constructor === Array) {
            data["AddAssociates"] = [];
            for (let item of this.addAssociates)
                data["AddAssociates"].push(item.toJSON());
        }
        if (this.deleteAssociates && this.deleteAssociates.constructor === Array) {
            data["DeleteAssociates"] = [];
            for (let item of this.deleteAssociates)
                data["DeleteAssociates"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IProcessUpdateProjectGroup {
    projectGroupId: string;
    name?: string | undefined;
    startDate: Date;
    addAssociates?: Associate[] | undefined;
    deleteAssociates?: Associate[] | undefined;
}

export class ProjectGroupPlan implements IProjectGroupPlan {
    id!: string;
    week!: number;
    day!: number;
    knowledgeTransferId!: string;
    knowledgeTransferName?: string | undefined;
    reference?: string | undefined;
    duration!: number;
    modeId!: string;
    modeName?: string | undefined;
    roleId!: string;
    roleName?: string | undefined;
    ownerId?: string | undefined;
    ownerName?: string | undefined;
    scheduledDate!: Date;
    projectGroupId!: string;

    constructor(data?: IProjectGroupPlan) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.week = data["Week"];
            this.day = data["Day"];
            this.knowledgeTransferId = data["KnowledgeTransferId"];
            this.knowledgeTransferName = data["KnowledgeTransferName"];
            this.reference = data["Reference"];
            this.duration = data["Duration"];
            this.modeId = data["ModeId"];
            this.modeName = data["ModeName"];
            this.roleId = data["RoleId"];
            this.roleName = data["RoleName"];
            this.ownerId = data["OwnerId"];
            this.ownerName = data["OwnerName"];
            this.scheduledDate = data["ScheduledDate"] ? new Date(data["ScheduledDate"].toString()) : <any>undefined;
            this.projectGroupId = data["ProjectGroupId"];
        }
    }

    static fromJS(data: any): ProjectGroupPlan {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectGroupPlan();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Week"] = this.week;
        data["Day"] = this.day;
        data["KnowledgeTransferId"] = this.knowledgeTransferId;
        data["KnowledgeTransferName"] = this.knowledgeTransferName;
        data["Reference"] = this.reference;
        data["Duration"] = this.duration;
        data["ModeId"] = this.modeId;
        data["ModeName"] = this.modeName;
        data["RoleId"] = this.roleId;
        data["RoleName"] = this.roleName;
        data["OwnerId"] = this.ownerId;
        data["OwnerName"] = this.ownerName;
        data["ScheduledDate"] = this.scheduledDate ? this.scheduledDate.toISOString() : <any>undefined;
        data["ProjectGroupId"] = this.projectGroupId;
        return data; 
    }
}

export interface IProjectGroupPlan {
    id: string;
    week: number;
    day: number;
    knowledgeTransferId: string;
    knowledgeTransferName?: string | undefined;
    reference?: string | undefined;
    duration: number;
    modeId: string;
    modeName?: string | undefined;
    roleId: string;
    roleName?: string | undefined;
    ownerId?: string | undefined;
    ownerName?: string | undefined;
    scheduledDate: Date;
    projectGroupId: string;
}

export class ProjectGroupPlanWithStatus extends ProjectGroupPlan implements IProjectGroupPlanWithStatus {
    totalCount!: number;
    completedCount!: number;

    constructor(data?: IProjectGroupPlanWithStatus) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.totalCount = data["TotalCount"];
            this.completedCount = data["CompletedCount"];
        }
    }

    static fromJS(data: any): ProjectGroupPlanWithStatus {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectGroupPlanWithStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TotalCount"] = this.totalCount;
        data["CompletedCount"] = this.completedCount;
        super.toJSON(data);
        return data; 
    }
}

export interface IProjectGroupPlanWithStatus extends IProjectGroupPlan {
    totalCount: number;
    completedCount: number;
}

export class CreateProjectGroupPlan implements ICreateProjectGroupPlan {
    week!: number;
    day!: number;
    projectGroupId!: string;
    knowledgeTransferId!: string;
    reference?: string | undefined;
    modeId!: string;
    roleId!: string;
    ownerId?: string | undefined;
    scheduledDate!: Date;

    constructor(data?: ICreateProjectGroupPlan) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.week = data["Week"];
            this.day = data["Day"];
            this.projectGroupId = data["ProjectGroupId"];
            this.knowledgeTransferId = data["KnowledgeTransferId"];
            this.reference = data["Reference"];
            this.modeId = data["ModeId"];
            this.roleId = data["RoleId"];
            this.ownerId = data["OwnerId"];
            this.scheduledDate = data["ScheduledDate"] ? new Date(data["ScheduledDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateProjectGroupPlan {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProjectGroupPlan();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Week"] = this.week;
        data["Day"] = this.day;
        data["ProjectGroupId"] = this.projectGroupId;
        data["KnowledgeTransferId"] = this.knowledgeTransferId;
        data["Reference"] = this.reference;
        data["ModeId"] = this.modeId;
        data["RoleId"] = this.roleId;
        data["OwnerId"] = this.ownerId;
        data["ScheduledDate"] = this.scheduledDate ? this.scheduledDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ICreateProjectGroupPlan {
    week: number;
    day: number;
    projectGroupId: string;
    knowledgeTransferId: string;
    reference?: string | undefined;
    modeId: string;
    roleId: string;
    ownerId?: string | undefined;
    scheduledDate: Date;
}

export class UpdateProjectGroupPlan implements IUpdateProjectGroupPlan {
    id!: string;
    week!: number;
    day!: number;
    knowledgeTransferId!: string;
    reference?: string | undefined;
    modeId!: string;
    roleId!: string;
    ownerId?: string | undefined;
    scheduledDate!: Date;

    constructor(data?: IUpdateProjectGroupPlan) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.week = data["Week"];
            this.day = data["Day"];
            this.knowledgeTransferId = data["KnowledgeTransferId"];
            this.reference = data["Reference"];
            this.modeId = data["ModeId"];
            this.roleId = data["RoleId"];
            this.ownerId = data["OwnerId"];
            this.scheduledDate = data["ScheduledDate"] ? new Date(data["ScheduledDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateProjectGroupPlan {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProjectGroupPlan();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Week"] = this.week;
        data["Day"] = this.day;
        data["KnowledgeTransferId"] = this.knowledgeTransferId;
        data["Reference"] = this.reference;
        data["ModeId"] = this.modeId;
        data["RoleId"] = this.roleId;
        data["OwnerId"] = this.ownerId;
        data["ScheduledDate"] = this.scheduledDate ? this.scheduledDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IUpdateProjectGroupPlan {
    id: string;
    week: number;
    day: number;
    knowledgeTransferId: string;
    reference?: string | undefined;
    modeId: string;
    roleId: string;
    ownerId?: string | undefined;
    scheduledDate: Date;
}

export class Team implements ITeam {
    id!: string;
    code?: string | undefined;
    name?: string | undefined;

    constructor(data?: ITeam) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.code = data["Code"];
            this.name = data["Name"];
        }
    }

    static fromJS(data: any): Team {
        data = typeof data === 'object' ? data : {};
        let result = new Team();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Code"] = this.code;
        data["Name"] = this.name;
        return data; 
    }
}

export interface ITeam {
    id: string;
    code?: string | undefined;
    name?: string | undefined;
}

export class Role implements IRole {
    id!: string;
    code?: string | undefined;
    name?: string | undefined;

    constructor(data?: IRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.code = data["Code"];
            this.name = data["Name"];
        }
    }

    static fromJS(data: any): Role {
        data = typeof data === 'object' ? data : {};
        let result = new Role();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Code"] = this.code;
        data["Name"] = this.name;
        return data; 
    }
}

export interface IRole {
    id: string;
    code?: string | undefined;
    name?: string | undefined;
}

export class UserRole implements IUserRole {
    userRoleId!: string;
    role?: string | undefined;
    roleDescription?: string | undefined;

    constructor(data?: IUserRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userRoleId = data["UserRoleId"];
            this.role = data["Role"];
            this.roleDescription = data["RoleDescription"];
        }
    }

    static fromJS(data: any): UserRole {
        data = typeof data === 'object' ? data : {};
        let result = new UserRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UserRoleId"] = this.userRoleId;
        data["Role"] = this.role;
        data["RoleDescription"] = this.roleDescription;
        return data; 
    }
}

export interface IUserRole {
    userRoleId: string;
    role?: string | undefined;
    roleDescription?: string | undefined;
}

export class UserInfoViewModel implements IUserInfoViewModel {
    email?: string | undefined;
    hasRegistered!: boolean;
    loginProvider?: string | undefined;

    constructor(data?: IUserInfoViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.email = data["Email"];
            this.hasRegistered = data["HasRegistered"];
            this.loginProvider = data["LoginProvider"];
        }
    }

    static fromJS(data: any): UserInfoViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserInfoViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Email"] = this.email;
        data["HasRegistered"] = this.hasRegistered;
        data["LoginProvider"] = this.loginProvider;
        return data; 
    }
}

export interface IUserInfoViewModel {
    email?: string | undefined;
    hasRegistered: boolean;
    loginProvider?: string | undefined;
}

export class ManageInfoViewModel implements IManageInfoViewModel {
    localLoginProvider?: string | undefined;
    email?: string | undefined;
    logins?: UserLoginInfoViewModel[] | undefined;
    externalLoginProviders?: ExternalLoginViewModel[] | undefined;

    constructor(data?: IManageInfoViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.localLoginProvider = data["LocalLoginProvider"];
            this.email = data["Email"];
            if (data["Logins"] && data["Logins"].constructor === Array) {
                this.logins = [] as any;
                for (let item of data["Logins"])
                    this.logins!.push(UserLoginInfoViewModel.fromJS(item));
            }
            if (data["ExternalLoginProviders"] && data["ExternalLoginProviders"].constructor === Array) {
                this.externalLoginProviders = [] as any;
                for (let item of data["ExternalLoginProviders"])
                    this.externalLoginProviders!.push(ExternalLoginViewModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ManageInfoViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ManageInfoViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["LocalLoginProvider"] = this.localLoginProvider;
        data["Email"] = this.email;
        if (this.logins && this.logins.constructor === Array) {
            data["Logins"] = [];
            for (let item of this.logins)
                data["Logins"].push(item.toJSON());
        }
        if (this.externalLoginProviders && this.externalLoginProviders.constructor === Array) {
            data["ExternalLoginProviders"] = [];
            for (let item of this.externalLoginProviders)
                data["ExternalLoginProviders"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IManageInfoViewModel {
    localLoginProvider?: string | undefined;
    email?: string | undefined;
    logins?: UserLoginInfoViewModel[] | undefined;
    externalLoginProviders?: ExternalLoginViewModel[] | undefined;
}

export class UserLoginInfoViewModel implements IUserLoginInfoViewModel {
    loginProvider?: string | undefined;
    providerKey?: string | undefined;

    constructor(data?: IUserLoginInfoViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.loginProvider = data["LoginProvider"];
            this.providerKey = data["ProviderKey"];
        }
    }

    static fromJS(data: any): UserLoginInfoViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginInfoViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["LoginProvider"] = this.loginProvider;
        data["ProviderKey"] = this.providerKey;
        return data; 
    }
}

export interface IUserLoginInfoViewModel {
    loginProvider?: string | undefined;
    providerKey?: string | undefined;
}

export class ExternalLoginViewModel implements IExternalLoginViewModel {
    name?: string | undefined;
    url?: string | undefined;
    state?: string | undefined;

    constructor(data?: IExternalLoginViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["Name"];
            this.url = data["Url"];
            this.state = data["State"];
        }
    }

    static fromJS(data: any): ExternalLoginViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Name"] = this.name;
        data["Url"] = this.url;
        data["State"] = this.state;
        return data; 
    }
}

export interface IExternalLoginViewModel {
    name?: string | undefined;
    url?: string | undefined;
    state?: string | undefined;
}

export class ChangePasswordBindingModel implements IChangePasswordBindingModel {
    oldPassword!: string;
    newPassword!: string;
    confirmPassword?: string | undefined;

    constructor(data?: IChangePasswordBindingModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.oldPassword = data["OldPassword"];
            this.newPassword = data["NewPassword"];
            this.confirmPassword = data["ConfirmPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordBindingModel {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordBindingModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["OldPassword"] = this.oldPassword;
        data["NewPassword"] = this.newPassword;
        data["ConfirmPassword"] = this.confirmPassword;
        return data; 
    }
}

export interface IChangePasswordBindingModel {
    oldPassword: string;
    newPassword: string;
    confirmPassword?: string | undefined;
}

export class SetPasswordBindingModel implements ISetPasswordBindingModel {
    newPassword!: string;
    confirmPassword?: string | undefined;

    constructor(data?: ISetPasswordBindingModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.newPassword = data["NewPassword"];
            this.confirmPassword = data["ConfirmPassword"];
        }
    }

    static fromJS(data: any): SetPasswordBindingModel {
        data = typeof data === 'object' ? data : {};
        let result = new SetPasswordBindingModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["NewPassword"] = this.newPassword;
        data["ConfirmPassword"] = this.confirmPassword;
        return data; 
    }
}

export interface ISetPasswordBindingModel {
    newPassword: string;
    confirmPassword?: string | undefined;
}

export class AddExternalLoginBindingModel implements IAddExternalLoginBindingModel {
    externalAccessToken!: string;

    constructor(data?: IAddExternalLoginBindingModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.externalAccessToken = data["ExternalAccessToken"];
        }
    }

    static fromJS(data: any): AddExternalLoginBindingModel {
        data = typeof data === 'object' ? data : {};
        let result = new AddExternalLoginBindingModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ExternalAccessToken"] = this.externalAccessToken;
        return data; 
    }
}

export interface IAddExternalLoginBindingModel {
    externalAccessToken: string;
}

export class RemoveLoginBindingModel implements IRemoveLoginBindingModel {
    loginProvider!: string;
    providerKey!: string;

    constructor(data?: IRemoveLoginBindingModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.loginProvider = data["LoginProvider"];
            this.providerKey = data["ProviderKey"];
        }
    }

    static fromJS(data: any): RemoveLoginBindingModel {
        data = typeof data === 'object' ? data : {};
        let result = new RemoveLoginBindingModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["LoginProvider"] = this.loginProvider;
        data["ProviderKey"] = this.providerKey;
        return data; 
    }
}

export interface IRemoveLoginBindingModel {
    loginProvider: string;
    providerKey: string;
}

export class RegisterBindingModel implements IRegisterBindingModel {
    email!: string;
    password!: string;
    confirmPassword?: string | undefined;

    constructor(data?: IRegisterBindingModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.email = data["Email"];
            this.password = data["Password"];
            this.confirmPassword = data["ConfirmPassword"];
        }
    }

    static fromJS(data: any): RegisterBindingModel {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterBindingModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Email"] = this.email;
        data["Password"] = this.password;
        data["ConfirmPassword"] = this.confirmPassword;
        return data; 
    }
}

export interface IRegisterBindingModel {
    email: string;
    password: string;
    confirmPassword?: string | undefined;
}

export class RegisterExternalBindingModel implements IRegisterExternalBindingModel {
    email!: string;

    constructor(data?: IRegisterExternalBindingModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.email = data["Email"];
        }
    }

    static fromJS(data: any): RegisterExternalBindingModel {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterExternalBindingModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Email"] = this.email;
        return data; 
    }
}

export interface IRegisterExternalBindingModel {
    email: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if(result !== null && result !== undefined)
        throw result;
    else
        throw new SwaggerException(message, status, response, headers, null);
}